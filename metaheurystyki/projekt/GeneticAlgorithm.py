import random

import numpy as np


def split_into_cars(individual):
    individual = np.array(individual)
    np_cars = np.split(individual, np.where(individual[:-1] == -1)[0])
    cars = []
    [car.tolist() for car in cars]
    for car in np_cars:
        car = car.tolist()
        if -1 in car:
            car.remove(-1)
        if len(car) > 0:
            cars.append(car)
    return cars



class GeneticAlgorithm:
    def __init__(self, data):
        self.data = data

    def random_individual(self):
        individual = [i for i in range(len(self.data))]
        [individual.append(-1) for _ in range(random.randint(5, 10))]
        random.shuffle(individual)
        return individual

    # return sum of adaptation from all population
    def calculate_population_adaptation_sum(self, population):
        sum = 0
        for individual in population:
            sum += self.calculate_adaptation(individual)
        return sum

    def calculate_population_adaptation_min(self, population):
        min = 1000000000000000000
        for individual in population:
            if min > self.calculate_adaptation(individual):
                min = self.calculate_adaptation(individual)
        return min

    # return adaptation value of one individual
    def calculate_adaptation(self, individual):
        time = 0
        cars = split_into_cars(individual)
        # distance_sum = 0
        for i in range(len(individual) - 1):
            client = self.data[individual[i]]
            next_client = self.data[individual[i + 1]]
            distance = client.distance_between(next_client)
            # delivery_time = time + distance
            # if delivery_time > next_client.end_time:
            #     return 0
            # elif delivery_time < next_client.start_time:
            #     time = next_client.start_time
            # else:
            time += distance
        # time -= self.data[0].start_time
        return time

    # return parents selected for crossing
    def roulette_selection(self, population):
        adaptation_sum = self.calculate_population_adaptation_sum(population)
        if adaptation_sum == 0:
            return population
        probability_table = {}
        for i in range(len(population)):
            probability_table[i] = self.calculate_adaptation(population[i]) / adaptation_sum
        indexes = random.choices(list(probability_table.keys()),
                                 weights=list(probability_table.values()),
                                 k=len(population))
        return [population[index] for index in indexes]

    # return parents selected for crossing
    def elite_selection(self, population):
        sorted_population = sorted(population, key=lambda item: self.calculate_adaptation(item))
        better_half = sorted_population[:len(sorted_population)//2]
        return better_half + better_half

    # return survivors and parents chosen for crossing
    def select_parents(self, population, crossing_probability, is_roulette):
        random.shuffle(population)
        number_to_selection = int(crossing_probability * len(population))
        individuals_to_selection = population[:number_to_selection]
        other_individuals = population[number_to_selection:]
        if is_roulette:
            return other_individuals, self.roulette_selection(individuals_to_selection)
        else:
            return other_individuals, self.elite_selection(individuals_to_selection)

    # return two children with crossed genes based on two parents
    def cross_genes(self, pair, is_single_pivot):
        pivot = random.randint(1, 24)
        pivot_2 = random.randint(1, 24)
        if pivot > pivot_2:
            pivot, pivot_2 = pivot_2, pivot
        if is_single_pivot:
            return [pair[0][:pivot] + pair[1][pivot:],
                    pair[1][:pivot] + pair[0][pivot:]]
        else:
            return [pair[0][:pivot] + pair[1][pivot:pivot_2] + pair[0][pivot_2:],
                    pair[1][:pivot] + pair[0][pivot:pivot_2] + pair[1][pivot_2:]]

    # return random pairs from population
    def select_pairs(self, population):
        pairs = []
        random.shuffle(population)

        i = 0
        while i < len(population) - 1:
            pairs.append([population[i], population[i + 1]])
            i += 2

        if len(population) % 2 == 1:
            pairs.append([population[len(population) - 1], population[0]])
        return pairs

    # return new population based on pairs of parents
    def new_generation(self, pairs, is_single_pivot):
        children = []
        for pair in pairs:
            children += self.cross_genes(pair, is_single_pivot)
        return children

    # return final population generated by genetic algorithm
    def calculate(self,
                  population_size=100,
                  number_of_iterations=300,
                  crossing_probability=1,
                  is_roulette=False,
                  is_single_pivot=True):
        population = []
        for i in range(population_size):
            population.append(self.random_individual())

        for i in range(number_of_iterations):
            survivors, parents = self.select_parents(population, crossing_probability, is_roulette)
            pairs = self.select_pairs(parents)
            children = self.new_generation(pairs, is_single_pivot)
            population = survivors + children
            print(self.calculate_population_adaptation_min(population))
        return population
