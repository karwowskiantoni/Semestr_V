import random

from bitarray.util import urandom

from data import DATA, BAG_MAX_WEIGHT


# generate individual with random genes
def random_individual():
    return urandom(26)


def calculate_population_adaptation(individuals):
    sum = 0
    for individual in individuals:
        sum += calculate_adaptation(individual)
    return sum


# return adaptation value of one individual
def calculate_adaptation(individual):
    if len(individual) != len(DATA):
        return "podano osobnika o błędnej długości: " + str(len(individual)) + " wymagana ilość genów: " + str(
            len(DATA))
    weight_sum = 0
    value_sum = 0
    for i in range(len(individual)):
        if individual[i]:
            weight_sum += DATA[i][1]
            value_sum += DATA[i][2]
    if weight_sum > BAG_MAX_WEIGHT:
        return 0
    else:
        return value_sum


# return individuals selected for breeding
def roulette_selection(population):
    adaptation_sum = calculate_population_adaptation(population)
    if adaptation_sum == 0:
        return population
    probability_table = {}
    for i in range(len(population)):
        probability_table[i] = calculate_adaptation(population[i]) / adaptation_sum
    indexes = random.choices(list(probability_table.keys()),
                             weights=list(probability_table.values()),
                             k=len(population))
    return [population[index] for index in indexes]


# return individuals selected for breeding
def elite_selection(population):
    ranking_table = {}
    for i in range(len(population)):
        ranking_table[i] = calculate_adaptation(population[i])
    indexes = sorted(ranking_table.items(), key=lambda item: -item[1])
    gowno = [population[indexes[i][0]] for i in range(int(len(population)/2))]
    return gowno + gowno


def select_parents(individuals, crossing_probability, is_roulette):
    random.shuffle(individuals)
    number_to_selection = int(crossing_probability * len(individuals))
    individuals_to_selection = individuals[:number_to_selection]
    other_individuals = individuals[number_to_selection:]
    if is_roulette:
        return other_individuals + roulette_selection(individuals_to_selection)
    else:
        return other_individuals + elite_selection(individuals_to_selection)


# generate 2 children with crossed genes based on 2 parents
def cross_genes(pair):
    pivot = random.randint(1, 24)
    return [pair[0][:pivot] + pair[1][pivot:], pair[1][:pivot] + pair[0][pivot:]]


# return random pairs from population
def marry_individuals(individuals):
    pairs = []
    random.shuffle(individuals)

    i = 0
    while i < len(individuals) - 1:
        pairs.append([individuals[i], individuals[i + 1]])
        i += 2

    if len(individuals) % 2 == 1:
        pairs.append([individuals[len(individuals) - 1], individuals[0]])
    return pairs


# return new population based on pairs of parents
def new_generation(pairs):
    new_individuals = []
    for pair in pairs:
        new_individuals += cross_genes(pair)
    return new_individuals


# return population with random genes changed
def mutate_population(individuals, probability):
    random.shuffle(individuals)
    for i in range(int(probability * len(individuals))):
        individuals[i].invert(random.randint(0, 25))
    return individuals


# return final population generated by genetic algorithm
# todo things to be parametrized
# 1.Number of pivots
# 2.Selection algorithm
# 5.Stop condition (number of iterations/minimum adaptation/adaptation change)
def genetic_algorithm(population_size, number_of_iterations, crossing_probability, mutating_probability, isRoulette):
    individuals = []
    for i in range(population_size):
        individuals.append(random_individual())

    for i in range(number_of_iterations):
        individuals = select_parents(individuals, crossing_probability, isRoulette)  # choose next parents
        pairs = marry_individuals(individuals)  # choose pairs from parents
        individuals = new_generation(pairs)  # generate new population based on parents
        individuals = mutate_population(individuals, mutating_probability)  # mutate population
    return individuals
