from data import DATA, BAG_MAX_WEIGHT
from bitarray.util import urandom


# return adaptation value of one individual
# ready
def calculate_adaptation(individual):
    if len(individual) != len(DATA):
        return "podano osobnika o błędnej długości: " + str(len(individual)) + " wymagana ilość genów: " + str(len(DATA))
    weight_sum = 0
    value_sum = 0
    for i in range(len(individual)):
        if individual[i]:
            weight_sum += DATA[i][1]
            value_sum += DATA[i][2]
    if weight_sum > BAG_MAX_WEIGHT:
        return 0
    else:
        return value_sum


# generate individual with random genes
# ready
def random_individual():
    return urandom(26)


# return individuals selected for breeding
# todo
def roulette_selection(individuals):
    new_individuals = []
    return new_individuals


# return individuals selected for breeding
# todo
def tournament_selection(individuals):
    new_individuals = []
    return new_individuals


# return individuals selected for breeding
# todo
def ranking_selection(individuals):
    new_individuals = []
    return new_individuals


# return random pairs from population
# ready ?
def marry_individuals(individuals):
    individuals = individuals.shuffle()
    pairs = []
    i = 0
    while i < len(individuals):
        pairs += [individuals[i], individuals[i+1]]
        i += 2
    return pairs


# return new population based on pairs of parents
# todo
def new_generation(pairs):
    new_individuals = []
    for pair in pairs:
        new_individuals.append(cross_genes(pair, "parameter should be there"))  # there should be something like flatmap
    return new_individuals


# return population with random genes changed
# todo
def mutate_population(individuals):
    return individuals


# generate 2 children with crossed genes based on 2 parents
# todo
def cross_genes(pair, pivot):
    children = []
    return children


# return final population generated by genetic algorithm
# ready?
# todo things to be parametrized
# 1.Pivot/Number of pivots
# 2.Selection algorithm
# 3.Mutation ratio
# 4.Population size DONE
# 5.Stop condition (number of iterations/minimum adaptation/adaptation change)

def genetic_algorithm(population_size, number_of_iterations):

    individuals = []
    for i in range(population_size):
        individuals.append(random_individual())

    for i in range(number_of_iterations):
        individuals = roulette_selection(individuals)  # choose next parents
        pairs = marry_individuals(individuals)  # choose pairs from parents
        individuals = new_generation(pairs)  # generate new population based on parents
        individuals = mutate_population(individuals)  # mutate population

    return individuals


