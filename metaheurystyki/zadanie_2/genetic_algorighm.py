import random

from data import DATA, BAG_MAX_WEIGHT
from bitarray.util import urandom


# generate individual with random genes
def random_individual():
    return urandom(26)


# return adaptation value of one individual
def calculate_adaptation(individual):
    if len(individual) != len(DATA):
        return "podano osobnika o błędnej długości: " + str(len(individual)) + " wymagana ilość genów: " + str(len(DATA))
    weight_sum = 0
    value_sum = 0
    for i in range(len(individual)):
        if individual[i]:
            weight_sum += DATA[i][1]
            value_sum += DATA[i][2]
    if weight_sum > BAG_MAX_WEIGHT:
        return 0
    else:
        return value_sum


# return individuals selected for breeding
def roulette_selection(population, crossing_probability):
    sum_of_adaptations = 0
    for individual in population:
        sum_of_adaptations += calculate_adaptation(individual)
    probability_table = {}
    for i in range(len(population)):
        probability_table[i] = calculate_adaptation(population[i])/sum_of_adaptations
    return random.choices(list(probability_table.keys()), weights=list(probability_table.values()), k=crossing_probability)


# generate 2 children with crossed genes based on 2 parents
# todo
def cross_genes(pair, pivot):
    first_pair_fhalf = pair[0][:pivot]
    first_pair_shalf = pair[0][pivot:]
    second_pair_fhalf = pair[1][:pivot]
    second_pair_shalf = pair[1][pivot:]

    first_child = first_pair_fhalf + second_pair_shalf
    second_child = second_pair_fhalf + first_pair_shalf

    return [first_child, second_child]

# return individuals selected for breeding
# todo
def tournament_selection(individuals):
    new_individuals = []
    return new_individuals


# return individuals selected for breeding
# todo
def ranking_selection(individuals):
    new_individuals = []
    return new_individuals


# return random pairs from population
# ready ?
def make_pairs(individuals):
    pairs = []
    random.shuffle(individuals)

    if len(individuals) % 2 == 0:
        i = 0
        while i < len(individuals):
            pairs.append([individuals[i], individuals[i + 1]])
            i += 2
    else:
        i = 0
        while i < len(individuals):
            if len(individuals) - i == 1:
                pairs.append([individuals[i], individuals[0]])
                return pairs
            else:
                pairs.append([individuals[i], individuals[i + 1]])
                i += 2
    return pairs


# return new population based on pairs of parents
# todo
def new_generation(pairs):
    new_individuals = []
    for pair in pairs:
        new_individuals.append(cross_genes(pair, "parameter should be there"))  # there should be something like flatmap TSOO
    return new_individuals


# return population with random genes changed
# todo
def mutate_population(individuals):
    return individuals


# return final population generated by genetic algorithm
# ready?
# todo things to be parametrized
# 1.Pivot/Number of pivots
# 2.Selection algorithm
# 3.Mutation ratio
# 4.Population size DONE
# 5.Stop condition (number of iterations/minimum adaptation/adaptation change)

def genetic_algorithm(population_size, crossing_probability):

    population = []
    for i in range(population_size):
        population.append(random_individual())
    # chosen_individuals = random.sample(population, crossing_probability)
    #loop
    parents_indices = roulette_selection(population, crossing_probability)
    parents = []
    for parent_index in parents_indices:
        parents.append(population[parent_index])
    print(parents)
    #crossing done
    #mutation todo

    # individuals = []
    # for i in range(population_size):
    #     individuals.append(random_individual())
    #
    # for i in range(number_of_iterations):
    #     individuals = roulette_selection(individuals)  # choose next parents
    #     pairs = marry_individuals(individuals)  # choose pairs from parents
    #     individuals = new_generation(pairs)  # generate new population based on parents
    #     individuals = mutate_population(individuals)  # mutate population


