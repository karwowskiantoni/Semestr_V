--1
--procedure which create order with products and realizations connected to specific employee and product_types
drop procedure createOrder
go
create procedure createOrder(@prod int, @amount int, @emp int, @location varchar(50))
as
begin
	declare @empExists int = (select count(*) from employee where id = @emp)
	declare @prodExists int = (select count(*) from product where id = @prod)
	declare @isBusy bit = (select is_busy from employee where id = @emp)
	if(@empExists = 1 or @prodExists = 1)
	begin
		if(@isBusy = 'False')
		begin
			update employee set is_busy = 'True' where id = @emp
			insert into "order" (acceptance_time, location) values (GETDATE(), @location)
			declare @order int = (select top 1 id from "order" order by id desc)
			insert into product_order (order_id, product_id, amount) values (@order, @prod, @amount)
			insert into employee_order (employee_id, order_id) values (@emp, @order)
			print 'Zlozono zamowienie'
		end
		else
		begin
			print 'Nie mozna zamowic. Pracownik zajety.'
		end
	end
	else 
	begin
		print 'Produkt lub pracownik nie istnieje'
	end
end
--
drop procedure completeOrder
go
create procedure completeOrder(@ord int)
as
begin
	declare @emp int = (select employee_id from employee_order where order_id = @ord)
	declare @busy bit = (select is_busy from employee where id = @emp)
	declare @realizationTime datetime = (select realization_time from "order" where id = @ord)
	if(@realizationTime is null and @busy = 'True')
	begin
		update "order" set realization_time = GETDATE() where id = @ord
		update employee set is_busy = 'False' where id = @emp
		print 'Zamowienie ukonczone'
	end
	else
	begin
		print 'Niespojnosc danych. Pracownik przypisany do zamowienia go nie obsluguje'
	end
end
exec createOrder 5, 3, 1, 'Czestochowa'
exec completeOrder  20
select * from "order"
--2
--remove product which was sold least times
drop procedure removeUnpopularProduct
go
create procedure removeUnpopularProduct
as
begin
	with productsCounter as (
	select p.id, count(p.id) as orders
	from product p
	left join product_order po on po.product_id = p.id
	group by p.id)

	delete from product where id = (select id
									from productsCounter
									where orders = (select min(orders) from productsCounter))
end

--3
--decrease salary of employee when his total profit (function below) in month is lower than salary
--tak sire nierobi podwyzka dla pracow2nika miesiaca o dany procent od jego zysku
drop procedure lowerSalary
go
create procedure lowerSalary(@emp int, @from datetime, @to datetime)
as
begin
	declare @isLower bit, @salary float, @totalProfit float
	set @salary = (select salary from employee where id = @emp)
	set @totalProfit = (dbo.timeProfit(@emp, @from, @to))
	if(@salary < @totalProfit)
	begin
		update employee set salary = salary * 0.8 where id = @emp
		print 'Pracownik zarobil mniej niz jego miesieczna pensja'
	end
	else
		print 'Pracownik zarobil wiecej niz jego miesieczna pensja.'
end

--function
--returns total profit generated by employee in period of time
drop function timeProfit
go
create function timeProfit(@emp int, @from datetime, @to datetime)
returns float
as
begin
	declare @sum float = 0.0
	declare kursor cursor for
	select price, amount
	from product p
	left join product_order po on po.product_id = p.id 
	left join "order" o on po.order_id = o.id
	left join employee_order eo on eo.order_id = po.order_id
	where eo.employee_id = @emp and o.realization_time >= @from and o.realization_time <= @to
	declare @price float, @amount int
	open kursor
	fetch next from kursor into @price, @amount
	while @@FETCH_STATUS = 0
		begin
			set @sum = @sum + (@price * @amount)
			fetch next from kursor into @price, @amount
		end
	close kursor
	deallocate kursor
	return @sum
end

select id, dbo.timeProfit(id, DATETIMEFROMPARTS(2000, 12, 1, 21,37, 22,0), GETDATE())
from employee